head	1.21;
access;
symbols;
locks
	crc:1.21; strict;
comment	@# @;


1.21
date	2013.11.19.23.47.39;	author jordan;	state Exp;
branches;
next	1.20;

1.20
date	2013.09.19.19.04.19;	author ubuntu;	state Exp;
branches;
next	1.19;

1.19
date	2013.09.19.18.38.30;	author crc;	state Exp;
branches;
next	1.18;

1.18
date	2013.07.28.21.50.02;	author jordan;	state Exp;
branches;
next	1.17;

1.17
date	2013.05.08.03.44.09;	author benson;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.18.00.25.28;	author jacob;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.17.08.23.04;	author benson;	state Exp;
branches;
next	1.14;

1.14
date	2013.02.12.06.53.32;	author jacob;	state Exp;
branches;
next	1.13;

1.13
date	2013.02.05.20.37.36;	author jacob;	state Exp;
branches;
next	1.12;

1.12
date	2013.02.05.19.38.37;	author jacob;	state Exp;
branches;
next	1.11;

1.11
date	2013.01.29.06.40.01;	author jacob;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.29.05.45.07;	author jacob;	state Exp;
branches;
next	1.9;

1.9
date	2013.01.28.00.52.08;	author jacob;	state Exp;
branches;
next	1.8;

1.8
date	2013.01.27.02.27.45;	author jacob;	state Exp;
branches;
next	1.7;

1.7
date	2013.01.27.02.18.07;	author jacob;	state Exp;
branches;
next	1.6;

1.6
date	2013.01.27.02.12.09;	author jacob;	state Exp;
branches;
next	1.5;

1.5
date	2013.01.27.02.07.32;	author jacob;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.27.01.24.02;	author jacob;	state Exp;
branches;
next	1.3;

1.3
date	2013.01.27.01.11.32;	author jacob;	state Exp;
branches;
next	1.2;

1.2
date	2013.01.27.00.34.07;	author jacob;	state Exp;
branches;
next	1.1;

1.1
date	2013.01.26.23.27.47;	author jacob;	state Exp;
branches;
next	;


desc
@Initial version of staging.
@


1.21
log
@*** empty log message ***
@
text
@<?php

/*
 * For a given nid/uid, returns:
 * 'Cancelled' - The event has been canceled.
 * 'Manager' - This event is assigned to that user as 'Manager'.
 * 'Coordinator' - This event is assigned to that user as 'Coordinator'.
 * 'Unassigned' - The user opted in to this event, but is not assigned.
 * ''  - The user did not opt in to this event.
 */
function brick_get_event_assigned_status($nid, $uid = null) {
	global $user;

	$event = node_load($nid);
	if ($event->field_event_status['und'][0]['value'] == 'Cancelled')
		return 'Cancelled';

	if ($uid == null)
		$uid = $user->uid;

	$res = db_query('SELECT field_optin_selected_value, field_optin_role_value
			FROM field_data_field_optin_selected selected
			INNER JOIN field_data_field_optin_event event ON (selected.entity_id = event.entity_id)
			INNER JOIN field_data_field_optin_person person ON (selected.entity_id = person.entity_id)
			INNER JOIN field_data_field_optin_role role ON (selected.entity_id = role.entity_id)
			WHERE	field_optin_person_uid = :uid AND
				field_optin_event_nid = :nid
			ORDER BY field_optin_selected_value DESC', // We grab the first, so prefer Yes to Staged
			array(	':uid' => $uid,
				':nid' => $nid));

	$row = $res->fetchAll();
	// If we get any result, we know they've opted in.
	if ($row) {
		if ($row[0]->field_optin_selected_value == 'Yes') {
			return $row[0]->field_optin_role_value;
                }
		return 'Unassigned';
	}

	return '';
}

/**
* Return a map of role to userId actually assigned to that role for a given event. 
* Staged users are not returned.
*/
function brick_get_assignment_map($eid) {
   $res = db_query('SELECT field_optin_selected_value, field_optin_role_value, field_optin_person_uid
                        FROM field_data_field_optin_selected selected
                        INNER JOIN field_data_field_optin_event event ON (selected.entity_id = event.entity_id)
                        INNER JOIN field_data_field_optin_person person ON (selected.entity_id = person.entity_id)
                        INNER JOIN field_data_field_optin_role role ON (selected.entity_id = role.entity_id)
                        WHERE field_optin_event_nid = :nid',
                        array( ':nid' => $eid));

   $rows = $res->fetchAll();
   $ret = array();
   // If we get any result, we know they've opted in.
   foreach ($rows as $row) {
   	if ($row->field_optin_selected_value == 'Yes') {
           $ret[$row->field_optin_role_value] = $row->field_optin_person_uid;
        }
   }

   return $ret;
}

function brick_ajax_stage($nid) {
	$optin_node = node_load($nid);
	$uid = $optin_node->field_optin_person['und'][0]['uid'];

	$status = brick_stage($nid, 0);
	$num = brick_get_num_assigned_from_pager($uid);

	echo json_encode(array(
		'uid' => $uid,
		'status' => $status,
		'num_assigned' => $num
	)), "\n";
}

// Data is passed in via $_POST params
function brick_ajax_check_staged() {
	$bad = array();

	foreach ($_POST as $status => $nids) {
		foreach ($nids as $nid) {
			if (! brick_check_stage($nid, $status)) {
				$bad[] = $nid;
			}
		}
	}

	if (empty($bad)) {
		echo json_encode(array(
			'status' => 'success',
		)), "\n";
	} else {
		echo json_encode(array(
			'status' => 'fail',
			'bad_nids' => $bad,
		)), "\n";
	}
}

// Returns whether the given NID matches the given staged status
function brick_check_stage($nid, $status) {
	$optin_node = node_load($nid);

	$selected = 'No';
	if (array_key_exists('field_optin_selected', $optin_node) &&
			array_key_exists('und', $optin_node->field_optin_selected)) {
		$selected = $optin_node->field_optin_selected['und'][0]['value'];
	}

	return ($selected == $status);
}

function brick_stage($nid, $redirect = 1) {
	$optin_node = node_load($nid);

	$save = 1;
	$selected = '';
	if (array_key_exists('field_optin_selected', $optin_node) &&
			array_key_exists('und', $optin_node->field_optin_selected)) {
		$selected = $optin_node->field_optin_selected['und'][0]['value'];
	}

	switch ($selected) {
		case 'No':
		case '':
			$selected = 'StagedYes';
			break;
		case 'StagedYes':
			$selected = 'No';
			break;
		case 'StagedNo':
			$selected = 'Yes';
			break;
		case 'Yes':
			$selected = 'StagedNo';
			break;
		default:
			$save = 0; // If we're not changing it, don't save it
	}

	if ($save) {
		$optin_node->field_optin_selected['und'][0]['value'] = $selected;
		node_save($optin_node);
	}

	if ($redirect) {
		brick_go_back();
	}

	return $selected;
}

function brick_assign_staged() {
	brick_change_staged('StagedYes', 'Yes');
	brick_change_staged('StagedNo', 'No');

	brick_add_assigned_rsvps();
	brick_remove_unassigned_rsvps();

	brick_go_back();
}

function brick_clear_staged() {
	brick_change_staged('StagedYes', 'No');
	brick_change_staged('StagedNo', 'Yes');

	brick_go_back();
}

function brick_change_staged($oldVal, $newVal) {
	$chapterId = $_SESSION['CHAPTER'];

	$startDate = brick_get_referer_date();
	$endDate = clone $startDate;
	$endDate->add(new DateInterval('P1M'));

	$res = db_query('SELECT selected.entity_id
			FROM field_data_field_optin_selected selected
			INNER JOIN field_data_field_optin_event event ON (selected.entity_id = event.entity_id)
			INNER JOIN field_data_field_event_chapter chapter ON (field_optin_event_nid = chapter.entity_id)
			INNER JOIN field_data_field_event_date date ON (field_optin_event_nid = date.entity_id)
			WHERE field_optin_selected_value = :oldVal
				AND field_event_chapter_nid = :chapterId
				AND field_event_date_value >= :startDate
				AND field_event_date_value < :endDate',
			array(	':oldVal' => $oldVal,
				':chapterId' => $chapterId,
				':startDate' => $startDate->format('Y-m-d'),
				':endDate' => $endDate->format('Y-m-d')));

	$nids = $res->fetchCol(0);

	foreach (node_load_multiple($nids) as $node) {
		$node->field_optin_selected['und'][0]['value'] = $newVal;
		node_save($node);
	}
}

function brick_go_back() {
	// Do a full page-refresh for now.
	if ($_SERVER['HTTP_REFERER']) {
		drupal_goto($_SERVER['HTTP_REFERER']);
	} else {
		drupal_goto('webmgr/assign-events');
	}
}

function brick_get_referer_date() {
	$referer = $_SERVER['HTTP_REFERER'];
	if (! $referer) {
		drupal_goto('webmgr/assign-events');
	}

	$date = new DateTime(date('Y-m'));

	// Mine the month out of the URL, if we can
	$parts = parse_url($referer);
	if (array_key_exists('query', $parts)) {
		parse_str($parts['query'], $query);
		if ($query && array_key_exists('date', $query)) {
			$date = new DateTime($query['date']);
		}
	}

	return $date;
}

function brick_get_num_assigned_from_pager($uid) {
	$month = brick_get_referer_date()->format('Y-m');
	return brick_get_num_assigned($uid, $month);
}

function brick_get_num_assigned_from_monthid($uid, $monthId) {
        $month = node_load($monthId)->field_availability_month['und'][0]['value'];
	return brick_get_num_assigned($uid, $month);
}

function brick_get_num_assigned($uid, $month) {
	$chapterId = $_SESSION['CHAPTER'];

	$startDate = new DateTime($month);
	$endDate = clone $startDate;
	$endDate->add(new DateInterval('P1M'));

	$res = db_query('SELECT COUNT(*)
			FROM field_data_field_optin_selected selected
			INNER JOIN field_data_field_optin_event event ON (selected.entity_id = event.entity_id)
			INNER JOIN field_data_field_optin_person person ON (selected.entity_id = person.entity_id)
			INNER JOIN field_data_field_event_date date ON (field_optin_event_nid = date.entity_id)
			INNER JOIN field_data_field_event_chapter chapter ON (field_optin_event_nid = chapter.entity_id)
			INNER JOIN field_data_field_event_status status ON (field_optin_event_nid = status.entity_id)
			WHERE field_optin_person_uid = :uid
				AND field_optin_selected_value IN (\'StagedYes\', \'Yes\')
				AND field_event_chapter_nid = :chapterId
				AND field_event_date_value >= :startDate
				AND field_event_date_value < :endDate
				AND field_event_status_value = \'Open\'',
			array(	':uid' => $uid,
				':chapterId' => $chapterId,
				':startDate' => $startDate->format('Y-m-d'),
				':endDate' => $endDate->format('Y-m-d')));

	$count = $res->fetchCol();
	return $count[0];
}

function brick_add_assigned_rsvps() {
	$chapterId = $_SESSION['CHAPTER'];

	$startDate = brick_get_referer_date();
	$endDate = clone $startDate;
	$endDate->add(new DateInterval('P1M'));

	$res = db_query('SELECT field_optin_person_uid,
				field_optin_event_nid,
				field_optin_role_value
			FROM field_data_field_optin_selected selected
			INNER JOIN field_data_field_optin_event event ON (selected.entity_id = event.entity_id)
			INNER JOIN field_data_field_event_chapter chapter ON (field_optin_event_nid = chapter.entity_id)
			INNER JOIN field_data_field_event_date date ON (field_optin_event_nid = date.entity_id)
			INNER JOIN field_data_field_optin_person person ON (person.entity_id = selected.entity_id)
			INNER JOIN field_data_field_optin_role role ON (role.entity_id = selected.entity_id)
			WHERE field_optin_selected_value = \'Yes\'
				AND field_event_chapter_nid = :chapterId
				AND field_event_date_value >= :startDate
				AND field_event_date_value < :endDate',
			array(	':chapterId' => $chapterId,
				':startDate' => $startDate->format('Y-m-d'),
				':endDate' => $endDate->format('Y-m-d')));

	foreach ($res as $row) {
		$eid = $row->field_optin_event_nid;
		$uid = $row->field_optin_person_uid;
		$role = $row->field_optin_role_value;
		$note = '';
		$created_when_assigned = '1';

		$rsvp_id = brick_get_rsvp_id($eid, $uid);
		if (! $rsvp_id) {
			brick_add_rsvp($eid, $uid, $note, 1, $role, $created_when_assigned);
		} else {
			$node = node_load($rsvp_id);
			$node->field_rsvp_role['und'][0]['value'] = $role;
			node_save($node);
		}
	}
}

function brick_remove_unassigned_rsvps() {
	$chapterId = $_SESSION['CHAPTER'];

	$startDate = brick_get_referer_date();
	$endDate = clone $startDate;
	$endDate->add(new DateInterval('P1M'));

	$res = db_query('SELECT field_optin_person_uid,
				field_optin_event_nid
			FROM field_data_field_optin_selected selected
			INNER JOIN field_data_field_optin_event event ON (selected.entity_id = event.entity_id)
			INNER JOIN field_data_field_event_chapter chapter ON (field_optin_event_nid = chapter.entity_id)
			INNER JOIN field_data_field_event_date date ON (field_optin_event_nid = date.entity_id)
			INNER JOIN field_data_field_optin_person person ON (person.entity_id = selected.entity_id)
			WHERE field_optin_selected_value = \'No\'
				AND field_event_chapter_nid = :chapterId
				AND field_event_date_value >= :startDate
				AND field_event_date_value < :endDate',
			array(	':chapterId' => $chapterId,
				':startDate' => $startDate->format('Y-m-d'),
				':endDate' => $endDate->format('Y-m-d')));

	foreach ($res as $row) {
		$eid = $row->field_optin_event_nid;
		$uid = $row->field_optin_person_uid;

		$rsvp_id = brick_get_rsvp_id($eid, $uid);
		if (! $rsvp_id)
			continue;

		$node = node_load($rsvp_id);

		// If auto-created, delete it entirely
		if (array_key_exists('und', $node->field_rsvp_created_when_assigned) &&
				$node->field_rsvp_created_when_assigned['und'][0]['value']) {
			node_delete($rsvp_id);

		// Otherwise, just change the role back to Volunteer
		} else {
			$node->field_rsvp_role['und'][0]['value'] = 'Volunteer';
			node_save($node);
		}
	}
}

?>
@


1.20
log
@*** empty log message ***
@
text
@d44 25
d241 2
a242 3
	return 0;
        //$month = node_load($monthId)->field_availability_month['und'][0]['value'];
	//return brick_get_num_assigned($uid, $month);
@


1.19
log
@add public flag to call to add_rsvp.
@
text
@d283 1
a283 1
			brick_add_rsvp($eid, $uid, $note, '1', $role, $created_when_assigned);
@


1.18
log
@*** empty log message ***
@
text
@d283 1
a283 1
			brick_add_rsvp($eid, $uid, $note, $role, $created_when_assigned);
@


1.17
log
@changed opt-in to assign-events
@
text
@d216 3
a218 2
	$month = node_load($monthId)->field_availability_month['und'][0]['value'];
	return brick_get_num_assigned($uid, $month);
@


1.16
log
@Add AJAX function for checking staged contents for NIDs.
@
text
@d186 1
a186 1
		drupal_goto('webmgr/opt-in');
d193 1
a193 1
		drupal_goto('webmgr/opt-in');
@


1.15
log
@*** empty log message ***
@
text
@d58 37
@


1.14
log
@More robust AJAXing.
@
text
@d5 4
a8 3
 * 'C' - The event has been canceled.
 * 'A' - This event is assigned to that user.
 * 'O' - The user opted in to this event, but is not assigned.
d16 1
a16 1
		return 'C';
d21 1
a21 1
	$res = db_query('SELECT field_optin_selected_value
d24 2
a25 1
			INNER JOIN field_data_field_optin_person person ON (person.entity_id = selected.entity_id)
d32 1
a32 2
	$selected = $res->fetchCol();

d34 5
a38 4
	if ($selected) {
		if ($selected[0] == 'Yes')
			return 'A';
		return 'O';
d196 1
d201 2
a202 1
				AND field_event_date_value < :endDate',
@


1.13
log
@Add AJAX flavor of staging.
Also, fix default redirects, since /opt-in has moved.
@
text
@d43 3
d47 7
a53 1
	echo json_encode(array('status' => $status)), "\n";
d171 11
a181 1
function brick_get_num_assigned($uid, $monthId) {
a182 1
	$month = node_load($monthId)->field_availability_month['und'][0]['value'];
@


1.12
log
@Automatically create/remove RSVPs for assigned people.
@
text
@d42 6
a47 1
function brick_stage($nid) {
d80 5
a84 1
	brick_go_back();
d138 1
a138 1
		drupal_goto('opt-in');
d145 1
a145 1
		drupal_goto('opt-in');
@


1.11
log
@Support new StagedYes/StagedNo values instead of just Staged.
@
text
@d82 3
a96 15
	$referer = $_SERVER['HTTP_REFERER'];
	if (! $referer) {
		drupal_goto('opt-in');
	}

	$startDate = new DateTime(date('Y-m'));

	// Mine the month out of the URL, if we can
	$parts = parse_url($referer);
	if (array_key_exists('query', $parts)) {
		parse_str($parts['query'], $query);
		if ($query && array_key_exists('date', $query)) {
			$startDate = new DateTime($query['date']);
		}
	}
d98 1
d133 20
d181 87
@


1.10
log
@New function to get an event's status code.
@
text
@d55 1
a55 1
			$selected = 'Staged';
d57 1
a57 1
		case 'Staged':
d60 6
d79 4
a82 1
	brick_change_staged('Yes');
d86 4
a89 1
	brick_change_staged('No');
d92 1
a92 1
function brick_change_staged($newVal) {
d118 1
a118 1
			WHERE field_optin_selected_value = \'Staged\'
d122 2
a123 1
			array(':chapterId' => $chapterId,
a132 2

	brick_go_back();
d159 1
a159 1
				AND field_optin_selected_value IN (\'Staged\', \'Yes\')
@


1.9
log
@Helper function to get number of staged/assigned events for a user.
@
text
@d3 39
@


1.8
log
@Make save/clear buttons work on bare /opt-in page without date.
@
text
@d34 1
a34 1
	brick_change_staged('Assigned');
d94 28
@


1.7
log
@A more-complete fix for the previous checkin.
@
text
@d48 3
a50 1
	// Mine the month out of the URL
d52 6
a57 1
	parse_str($parts['query'], $query);
a58 1
	$startDate = new DateTime($query['date']);
@


1.6
log
@Avoid a warning when this key isn't present.
@
text
@d8 2
a9 1
	if (array_key_exists('field_optin_selected', $optin_node)) {
@


1.5
log
@Restrict clearing/saving staged opt-ins to only the pager month.
@
text
@d7 4
a10 1
	$selected = $optin_node->field_optin_selected['und'][0]['value'];
@


1.4
log
@Go back to referer, if available.
@
text
@d39 12
d56 1
d58 6
a63 2
				AND field_event_chapter_nid = :chapterId',
			array(':chapterId' => $chapterId));
@


1.3
log
@Assume empty 'selected' is equivalent to 'No'.
@
text
@d26 1
a26 2
	// Do a full page-refresh for now.
	drupal_goto('opt-in');
d55 4
d60 5
a64 1
	drupal_goto('opt-in');
@


1.2
log
@Add ability to save or clear all staged opt-ins for a chapter.
@
text
@d11 1
@


1.1
log
@Initial revision
@
text
@d29 30
@
